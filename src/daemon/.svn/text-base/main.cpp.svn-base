#include "doclibd_includes.hpp"
#include "../core/doclib_core.hpp"
#include "../libmgr/doc_database.hpp"
#include "../version.hpp"


using namespace std;

/**
 * Enumerations of the different possibilities after application startup
 */
enum eStartupReturn
{
	esr_PRINT_HELP
};

// local instances
string config_file;
string version;
doclib::core::doclib_conf cfg;

void set_version_string()
{
	version.assign(lexical_cast<string>(DOCLIBD_VERSION_VERSION));
	version.append(".");
	version.append(lexical_cast<string>(DOCLIBD_VERSION_BUILD));
}

int treat_command_line(int argc, char ** argv)
{
	// Declare the supported options.
	po::options_description desc("Allowed options");
	desc.add_options()
		("help,h", "produce help message")
		("config-file,c", po::value<string>(), "set configuration from filename instead")
		;

	po::variables_map vm;
	po::store(po::parse_command_line(argc, argv, desc), vm);
	po::notify(vm);

	if (vm.count("help"))
	{
		cout << "DocLibrary version " << version << "\n";
		cout << desc << "\n";
		return EXIT_FAILURE;
	}

	if (vm.count("config-file"))
	{
		cout << "using "
			<< vm["config-file"].as<string>() << " as configuration file." << endl;
		config_file = vm["config-file"].as<string>();
	} else {
		// set default configuration file
		config_file = string(DOCLIBD_DEFAULT_CFG_FILENAME);
	}

	return EXIT_SUCCESS;
}



int main(int argc, char ** argv)
{
	set_version_string();
	treat_command_line(argc, argv);

	if (cfg.load(config_file))
	{
		doclib::core::core_services::init_logging(cfg.log_filename, bl::level::debug);
		LDBG_ << "successfully loaded configuration file";
		
		doclib::libmgr::doc_database::create_instance(cfg);
		return EXIT_SUCCESS;
	}
	else
		cerr << "incorrect configuration (" << config_file << ")" << endl;

	return EXIT_FAILURE;

}
